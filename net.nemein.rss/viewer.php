<?php
/**
 * @package net.nemein.rss
 * @author The Midgard Project, http://www.midgard-project.org 
 * @version $Id$
 * @copyright The Midgard Project, http://www.midgard-project.org
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 */

/**
 * RSS Aggregator Site interface class.
 * 
 * @package net.nemein.rss
 */
class net_nemein_rss_viewer {

    var $_debug_prefix;

    var $_config;

    var $_topic;
    var $_feed;
    var $_latest;
    var $_view;
    var $_rss;
    var $_topic_mode;
    var $_subscription_mode;
    var $_channels;
    var $_encoding;

    var $_updated;

    function net_nemein_rss_viewer($topic, $config) {

        $this->_debug_prefix = "net.nemein.rss viewer::";

        $this->_config = $config;
        $this->_topic = $topic;
        $this->_feed = false;
        $this->_latest = $this->_config->get("show_latest");
        $this->_view = false;
        $this->_rss = false;
        $this->_topic_mode = $this->_config->get("topic_mode");
        $this->_subscription_mode = $this->_config->get("subscription_mode");
        $this->_channels = $this->_listChannels();
        $this->_updated = $this->_topic->revised;

        // get l10n libraries
        $i18n =& $GLOBALS["midcom"]->get_service("i18n");
        $GLOBALS["view_l10n"] = $i18n->get_l10n("net.nemein.rss");
        $this->_encoding = $i18n->get_current_charset();

    }

  function _getFeed($argc, $argv) {
  
    debug_push($this->_debug_prefix . "_getFeed");

    if ($argc == 0) {
      // View topic, thread listing
      debug_add("News aggregator front page");
      $this->_view = "topic";
      return true;
    }

    if ($argc == 1) {

      if ($argv[0] == "rss.xml") {

        // Show combined RSS view
        debug_add("Combined RSS view");

        $this->_rss = true;
        $GLOBALS["midcom"]->cache->content->content_type("text/xml; charset=".$this->_encoding);
        $GLOBALS["midcom"]->header("Content-type: text/xml; charset=".$this->_encoding);

        $server_url = $GLOBALS["midcom"]->get_host_name();
        $prefix = $GLOBALS["midcom"]->get_context_data(MIDCOM_CONTEXT_ANCHORPREFIX);
        echo "<?xml version=\"1.0\" encoding=\"".$this->_encoding."\"?>\n";
        echo "<rss version=\"2.0\">\n";
        echo "<channel>\n";
        echo "<title>".htmlspecialchars($this->_topic->extra)."</title>\n";
        echo "<link>".$server_url.$prefix."</link>\n";
        echo "<description>".$this->_config->get("rss_description")."</description>\n";
        echo "<generator>Midgard Components Framework - net.nemein.rss</generator>\n";

        // Show combined view as RSS
        $this->_getChannelsCombined($this->_config->get("rss_items"));

        echo "</channel>\n";
        echo "</rss>\n";
        $GLOBALS["midcom"]->finish();
        exit();

      } elseif ($argv[0] == "channels.opml") {

        // show OPML listing of subcribed channels
        debug_add("OPML listing of subscriptions");

        if (count($this->_channels) > 0) {
          // Show OPML headers
          $GLOBALS["midcom"]->cache->content->content_type("text/xml");
          $GLOBALS["midcom"]->header("Content-type: text/xml");
          echo "<?xml version=\"1.0\" encoding=\"".$this->_encoding."\"?>\n";
          echo "<!-- OPML generated by net.nemein.rss for Midgard ".mgd_version()." on ".date('r',time())." -->\n";
          echo "<opml version=\"1.1\">\n";
          echo "<head>\n";
          echo "  <title>".htmlspecialchars($this->_topic->extra)."</title>\n";
          echo "  <dateCreated>".date('r',$this->_topic->created)."</dateCreated>\n";
          echo "  <dateModified>".date('r',$this->_updated)."</dateModified>\n";
          echo "</head>\n";

          echo "<body>\n";
          foreach ($this->_channels as $url => $data) {
            $title = $data["title"];

            // We have to change the channel URL for Bloglines to hide passwords
            if ($this->_subscription_mode == "bloglines") {
              $url = str_replace(rawurlencode($this->_config->get("bloglines_username")).":".$this->_config->get("bloglines_password")."@","",$url);
            }

            echo "  <outline text=\"".htmlspecialchars($title)."\" xmlUrl=\"".htmlspecialchars($url)."\" />\n";
          }
          echo "</body>\n";

          // Show OPML footers and exit
          echo "</opml>\n";
          $GLOBALS["midcom"]->finish();
          exit();
        } else {
          return false;
        }

      } else {
        // Fetch the requested channel
        $this->_feed = mgd_get_article_by_name($this->_topic->id,$argv[0]);
        if (!$this->_feed) {
          debug_add("Feed $argv[0] could not be loaded: " . mgd_errstr(), MIDCOM_LOG_INFO);
          $this->errstr = "Feed $argv[0] could not be loaded: " . mgd_errstr();
          $this->errcode = MIDCOM_ERRNOTFOUND;
          return false;
        }
      
        $this->_view = "feed";
        $GLOBALS['midcom_component_data']['net.nemein.rss']['active_leaf'] = $this->_feed->id;
      
        return true;
      }

    } elseif ($argc == 2) {
    
      if ($argv[0] == "rss") {

        // Compatibility fix, redirect to /rss.xml
        // Remove this in next major release
        $server_url = $GLOBALS["midcom"]->get_host_name();
        $prefix = $GLOBALS["midcom"]->get_context_data(MIDCOM_CONTEXT_ANCHORPREFIX);
        header("location: ".$server_url.$prefix."rss.xml");
        exit();

      } elseif ($argv[0] == "combine") {

        $this->_view = "combine";
        $this->_latest = $argv[1];
        
        return true;
      }
    
    } elseif ($argc == 3) {
    
      $this->_feed = mgd_get_article_by_name($this->_topic->id,$argv[0]);
      if (!$this->_feed) {
        debug_add("Feed $argv[0] could not be loaded: " . mgd_errstr(), MIDCOM_LOG_INFO);
        $this->errstr = "Feed $argv[0] could not be loaded: " . mgd_errstr();
        $this->errcode = MIDCOM_ERRNOTFOUND;
        return false;
      }
      if ($argv[1] == "latest") {

        // View latest N items from the selected feed

        $this->_view = "latest";
        $this->_latest = $argv[2];
        return true;
      }
      
    } else {

      debug_add("too many parameters", MIDCOM_LOG_DEBUG);
      debug_pop();
      return false;
    }
  }

    function can_handle($argc, $argv) {

        debug_push($this->_debug_prefix . "can_handle");

        // see if we can handle this request.
        return $this->_getFeed($argc,$argv);

        debug_pop();
        return true;
    }


    function handle()
    {

        debug_push($this->_debug_prefix . "handle");

        // Tell cache to expire same time as Magpie RSS's cache
        $GLOBALS["midcom"]->cache->content->expires(time() + MAGPIE_CACHE_AGE);
        
        // RSS autodetection
        $url_prefix = $GLOBALS["midcom"]->get_context_data(MIDCOM_CONTEXT_ANCHORPREFIX);
        $GLOBALS["midcom"]->add_link_head(
            array(
                'rel' => 'alternate',
                'type' => 'application/rss+xml',
                'title' => 'RSS',
                'href' => $url_prefix."rss.xml",
            )
        );
        
        // OPML autodetection
        // Based on example in http://www.the-emperor.org/wiki/wrist_action_to_do_list/
        $GLOBALS["midcom"]->add_link_head(
            array(
                'rel' => 'subscriptions',
                'type' => 'text/x-opml',
                'title' => 'OPML',
                'href' => $url_prefix."channels.opml",
            )
        );


        debug_pop();
        return true;
    }
 
  function _listChannels() {
    $channels = array();

    if ($this->_subscription_mode == "bloglines") {
      if ($this->_config->get("bloglines_username") && $this->_config->get("bloglines_password")) {

        // We have OPML file, parse it
        $opml_handle = fopen("http://".rawurlencode($this->_config->get("bloglines_username")).":".$this->_config->get("bloglines_password")."@rpc.bloglines.com/listsubs", "r");
        $opml_data = "";
        while (!feof($opml_handle)) {
          $opml_data .= fread($opml_handle, 8192);
        }
        fclose($opml_handle);

        if ($opml_data != "") {
          $opml_parser = xml_parser_create();
          xml_parse_into_struct($opml_parser, $opml_data, $opml_values );
          foreach ($opml_values as $opml_element) {
            if ($opml_element["tag"] === "OUTLINE" ) {
              // Display found channels
              if (isset($opml_element["attributes"])) {
                if (isset($opml_element["attributes"]["BLOGLINESSUBID"])) {
                  // Fetch items from Bloglines instead of actual RSS source
                  $channels["http://".rawurlencode($this->_config->get("bloglines_username")).":".$this->_config->get("bloglines_password")."@rpc.bloglines.com/getitems?s=".$opml_element["attributes"]["BLOGLINESSUBID"]."&n=0"] = $opml_element["attributes"]["TITLE"];
                } elseif (isset($opml_element["attributes"]["XMLURL"])) {
                  $channels[$opml_element["attributes"]["XMLURL"]] = array(
                    "title" => $opml_element["attributes"]["TITLE"],
                    "icon"  => null);
                }
              }
            }
          }
          xml_parser_free($opml_parser);
        }
      }
    } else {
      $articles = mgd_list_topic_articles($this->_topic->id,"score");
      if ($articles) {
        while ($articles->fetch()) {
          $channels[$articles->url] = array(
            "title" => $articles->title,
            "icon"  => $articles->extra1);

          if ($articles->revised > $this->_updated) {
            $this->_updated = $articles->revised;
          }
        }
      }
    }
    return $channels;
  }

    function _getItemDate($item)
    {
        $date = null;
        if (is_array($item))
        {
            // RSS 0.9 and 2.0 pubDate attribute
            if (array_key_exists('pubdate', $item))
            {
                $date = strtotime($item['pubdate']);     
                debug_add('Read RSS 0.9 or 2.0 pubDate as '.date('r',$date)); 
            }
            // RSS 1.0 Dublin Core date attribute            
            elseif (   array_key_exists('dc', $item)
                    && array_key_exists('date', $item['dc']))
            {

                error_reporting(E_WARNING);
                $date = parse_w3cdtf($item['dc']['date']);
                error_reporting(E_ALL);

                if ($date == -1)
                {
                    // Fallback for broken RSS timestamps from #24
                    $date = strtotime($item['dc']['date']);
                }
                debug_add('Read RSS 1.0 dc:date as '.date('r',$date));
            }
            // Atom created attribute
            elseif (array_key_exists('created', $item))
            {
                error_reporting(E_WARNING);
                $date = parse_w3cdtf($item['created']);
                error_reporting(E_ALL);

                debug_add('Read Atom created as '.date('r',$date)); 
            }
        }
        
        if ($date > $this->_updated) {
            $this->_updated = $date;
        }
        
        return $date;
    }

  function _fixItem($item) {
    if (is_array($item)) {
      // Fix missing titles
      if (!isset($item["title"]) || !$item["title"]) {
        $item["title"] = $GLOBALS["view_l10n"]->get("untitled");
        $item_date = $this->_getItemDate($item);

        // Use 20 first characters from the description as title
        if (isset($item["description"])) {
          $item["title"] = substr(strip_tags($item["description"]),0,20)."...";

        // Use publication date as title
        } elseif ($item_date) {
          $item["title"] = strftime("%x",$item_date);
        }
      }

      // Fix missing links
      if (!isset($item["link"]) || !$item["link"]) {
        $item["link"] = "";
        if (isset($item["guid"])) {
          $item["link"] = $item["guid"];
        } 
      }

      // Fix missing GUIDs
      if (!isset($item["guid"]) || !$item["guid"]) {
        if (isset($item["link"])) {
          $item["guid"] = $item["link"];
        } 
      }

      // Set item content always to description
      if (isset($item["content"]) && isset($item["content"]["encoded"])) {
        $item["description"] = $item["content"]["encoded"];
      } elseif (!isset($item["description"]) || !$item["description"]) {
        $item["description"] = "";
      }

    }
    return $item;
  }

  function _getChannel($url,$show_items="all",$icon=null) {
    global $view_channel;
    global $view_item;
    global $view_item_date;

    error_reporting(E_WARNING);
    $rss = fetch_rss($url);
    error_reporting(E_ALL);

    if ($rss) {
      $view_channel = $rss->channel;      
      midcom_show_style("view-".$this->_view."-channel-header");
      while ($show_items && (list($key,$item) = each($rss->items))) {

        // Bloglines normalizes feeds for us
        if ($this->_subscription_mode == "bloglines") {
          $view_item = $item;
        } else {
          $view_item = $this->_fixItem($item);
        }

        $view_item_date = $this->_getItemDate($view_item);
        midcom_show_style("view-".$this->_view."-channel-item");
        if ($show_items != "all") {
          $show_items--;
        }
      }
                
      midcom_show_style("view-".$this->_view."-channel-footer");
      unset($rss);
    }
  
  }
  
  function _getChannelsCombined($show_items="all") {

    debug_push($this->_debug_prefix . "_getChannelsCombined");

    global $view_channel;
    global $view_item;
    global $view_item_date;
    
    $all_items = array();
    $items_in_date = array();

    foreach ($this->_channels as $channel_url => $channel_data) {

      $channel_title = $channel_data["title"];
      $channel_icon = $channel_data["icon"];
      debug_add($channel_title.": Fetching feed ".$channel_url);
      error_reporting(E_WARNING);
      $rss = fetch_rss($channel_url);
      error_reporting(E_ALL);

      if ($rss) {
        while (list($key,$item) = each($rss->items)) {

          // Bloglines normalizes feeds for us
          if ($this->_subscription_mode != "bloglines") {
            $item = $this->_fixItem($item);
          }

          $date = false;
          $dateitem = 0;
            
          // Find out publication date of item
          $date = $this->_getItemDate($item);
          if ($date) {
            if (isset($items_in_date[$date])) {
              $items_in_date[$date]++;
            } else {
              $items_in_date[$date] = 1;
            }
            $all_items[$date.".".$items_in_date[$date]] = $item;
            $all_items[$date.".".$items_in_date[$date]]["channel"] = $rss->channel;
            $all_items[$date.".".$items_in_date[$date]]["channel"]["rss"] = $channel_url;
            // Override channel title if requested
            if ($this->_config->get("topic_name_display") == "local") {
              $all_items[$date.".".$items_in_date[$date]]["channel"]["title"] = $channel_title;
            }
            $all_items[$date.".".$items_in_date[$date]]["channel"]["icon"] = $channel_icon;
          }
        }
      } else {
        debug_add("Failed to get feed, ".magpie_error());
      }
      unset($rss);
    }
      
      
    if (count($all_items) > 0) {
      // Arrange items by creation date
      krsort($all_items);
      
      $shown_permalinks = array();
      
      foreach ($all_items as $view_item) {
            
        if ($show_items) {

          // Prevent displaying same RSS item twice
          if ($view_item["guid"])
          {
              if (in_array($view_item["guid"],$shown_permalinks))
              {
                  // This item has been shown, skip to next
                  continue;
              } else {
                  $shown_permalinks[] = $view_item["guid"];
              }
          }
        
          $view_item_date = $this->_getItemDate($view_item);
          // Show RSS item inline
          if ($this->_rss) {
          
            // Add channel icon to RSS output if available
            if ($view_item["channel"]["icon"]) {
              $view_item["description"] = "<a href=\"".$view_item["channel"]["link"]."\"><img src=\"".$view_item["channel"]["icon"]."\" align=\"right\" border=\"0\" alt=\"".$view_item["channel"]["title"]."\" /></a>\n".$view_item["description"];
            }

            echo "<item>\n";
            echo "<title>".htmlspecialchars($view_item["title"])."</title>\n";
            echo "<description><!"."[CDATA[".$view_item["description"]."]]"."></description>\n";
            echo "<link>".htmlspecialchars($view_item["link"])."</link>\n";
            echo "<guid isPermaLink=\"true\">".htmlspecialchars($view_item["guid"])."</guid>\n";
            echo "<pubDate>".date('r',$view_item_date)."</pubDate>\n";
            if (isset($view_item["author"]) && $view_item["author"]) {
              echo "<author>";
              echo htmlspecialchars($view_item["author"]);
              echo "</author>\n";
            } elseif (isset($view_item["channel"]["webmaster"]) && $view_item["channel"]["webmaster"]) {
              echo "<author>";
              echo $view_item["channel"]["webmaster"]." (".htmlspecialchars($view_item["channel"]["title"]).")";
              echo "</author>\n";
            }
            echo "<source url=\"".$view_item["channel"]["rss"]."\">".htmlspecialchars($view_item["channel"]["title"])."</source>\n";
            echo "<category>".htmlspecialchars($view_item["channel"]["title"])."</category>\n";
            echo "</item>\n";

          } else {
            if ($this->_view == "topic") {
              $item_display = $this->_config->get("topic_item_display");
              if ($item_display == "details") {
                midcom_show_style("view-item-details");
              } else {
                midcom_show_style("view-combine-channel-item");
              }
            } else {
              midcom_show_style("view-".$this->_view."-channel-item");
            }
          }
        }
        if ($show_items != "all") {
          $show_items--;
        }
      }
    } else {
      debug_add("No items found");
    }
    debug_pop();
  }
  

  function show() {

    debug_push($this->_debug_prefix . "show");
    error_reporting(E_WARNING);

    if ($this->_view == "topic") {
      // Display topic index
      global $view_topic;
      $view_topic = $this->_topic;

      midcom_show_style("view-topic-header");

      if ($this->_topic_mode == "channels") {

        // Show channels separately
        foreach ($this->_channels as $url => $title) {
          $this->_getChannel($url,$this->_latest);
        }

      } elseif ($this->_topic_mode == "combined") {

        // Show latest N items combined from all channels
        $this->_getChannelsCombined($this->_latest);

      }

      midcom_show_style("view-topic-footer");

    } elseif ($this->_view == "feed") {

      // Display single feed
      $this->_getChannel($this->_feed->url);

    } elseif ($this->_view == "latest") {

      // Show latest N items from channel
      $this->_getChannel($this->_feed->url,$this->_latest);

    } elseif ($this->_view == "combine") {

       // Show latest N items combined from all channels
       $this->_getChannelsCombined($this->_latest);

    }

    error_reporting(E_ALL);

    debug_pop();
    return true;

  }


    function get_metadata() {

        // metadata for the current element
        return array (
            MIDCOM_META_CREATOR => "",
            MIDCOM_META_EDITOR => "",
            MIDCOM_META_CREATED => $this->_topic->created,
            MIDCOM_META_EDITED => $this->_updated,
        );
    }

} // viewer

?>
